1.상속
	상속 - 객체 지향 문법의 핵심
	상속해야하는 이유 : 아무것도 없는상태에서 만드려니 힘드니까 원래 구현되어 있는거에서 좀 추가해서 쓰자!!!

	장점
	 -객체의 재사용으로 인한 개발 시간과 비용 감소
	 -클래스에 대한 독립적인 테스트로 디버깅이 용이함
	
	상속의 개념
	 - 상속이랑 부모 클래스의 멤버 변수와 메쏘드를 물려받는것을 의미
	 - 자식 클래스는 부모 클래스의 모든 속성을물려 받음 (private는 접근, 상속 할수 없다.)
	 - 자식 클래스는 부모로부터 상속받은 속성 외에 자신만의 속성을 지닐수 있음


			------- 상속 예제 1------
			public class Shape {
			int x; int y;
			public Shape(int x, int y)
			{
			this.x = x; this.y = y;
			}
			}
			
			public class Circle extends Shape{
			int r;
			public Circle(){
			super(0,0); //부모꺼 먼저 수행 이게 없으면 컴파일러가 super();을 수행하는데 이런형태가 없을시 오류뜸
			this.r = 1;      //내꺼 수행
			}
			}
			
			-------------------------

	상속의 특성
	 - 상속되는것 : 대부분의 멤버 변수와 멤버 메소드
	 - 상속되지 않는것
			명시적으로 숨긴 변수
			상위클래스에서 오버라이드한 메쏘드
			생성자(생성자는 멤버 메쏘드가 아니다)
			상위클래스에 존재하는 멤버 변수와 동일한 이름의 멤버 변수를 하위 크래스에 선언한 경우
			 - JAVA에서는 다중 상속을 허용하지 않음 -> 인터페이스를 이용하여 유사한 효과를 얻음
	
	super 키워드
	-상속된 객체의 생성시 부모 클래스의 생성자가 먼저 호출되고 자식 클래스의 생성자가 호출 됨
	-명시적으로 부모 클래스의 생성자를 호출하지 않을 경우 부모 클래스의 기본 생성자가 수행됨
	
	겟터 셋터
	객체의 속성은 일반적으로 비공개라서
	메소드로 꺼내서 받아온다
	
	


2. 캡슐화(  정보은닉 )
	
	객체지행 기반의 클래스 설계에서 정보은닉 => 캡슐화
	추상화를 한 목적에 따라 인스턴스를 사용할  수 있도록 무효한 접근을 방지.
 
	접근 지정자
	public          클래스 내부, 동일 패키지, 하위 클래스, 그 외의 영역
	protected       클래스 내부, 동일 패키지, 하위 클래스
	default         클래스 내부, 동일 패키지
	private         클래스 내부



3. 다형성
	다형성
	 - 서로 다른객체가 같은 메쏘드에 대하여 다른 행위를 하도록 동적 바인딩을 사용하는것
	 - 상속된 객체에 대해 부모 클래스의 메쏘드를 호출하였을때
	   그 메쏘드에서 사용되는다른 메쏘드가 자식 클래스에 다시 정의(오버라이딩)된 경우 자식 클래스의 메쏘드가 동적으로 바인딩 됨
	   
		
			------------다형성 예제------------------------
			Object x = new Shape();
			Shape s = new Circle();       // 동적 바인딩, 실행시에 결정
			부모 a = new 자식();
			이 된다. 반대는 안된다. 항상 부모>자식
			-------------------------------------------------
			




오버로딩(  overloading ) 
	생성자,메소드,다중정의,동일한 이름에  상이한 시그너처,한 클래스 내에 선언 

			
			-------오버로딩 예제 1번 ---------------------------
			 public Car(String name){     // 그런데 이렇게 생성자를만들어주면 디폴트로생성
			  this.name = name;
			 }
			 public Car(){}                 // 이거 같이넣어주면 값없이도 생성가능
			
			-------오버로딩 예제 2번 ---------------------------
			 public TV(boolean power, int channel, int volume) // private도 되는데 하면 자기밖에 안됨
			 {
			  this(power,channel);        // 중복된거를 생성자로 대체할때 생성자 호출이 앞에 먼저와야된다.
			//  this.power = power;
			//  this.channel = channel;
			  this.volume = volume;      //추가로 할것
			 }
			 public TV(boolean power, int channel){
			 
			  this.channel = channel;
			  this.power = power;
			  
			 }
			
			-----------------------------------------------------
			

오버라이딩( overriding )
	메소드,상속과 함께  나타남  (한 메쏘드는 부모 클래스에 다른 메쏘드는 자식 클래스에 존재 )
	재정의, 동일한 메쏘드  이름에 동일한 시그너쳐를 가짐
			
			------------오버라이딩 예제 ---------------------------
			
			public abstract class Shape {
				
				public abstract void draw();
				
				public abstract double calculateArea();
			
			}
			
			public class Rect extends Shape implements Drawble{
				
				
				@Override
				public void draw(){
					System.out.println("사각형을 그렸습니다.");
				}
			
				@Override
				public double calculateArea() {
					
					return width * height;
				}
				
				
			}
			
			--------------------------------------------------------
